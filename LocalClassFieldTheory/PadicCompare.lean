import LocalClassFieldTheory.DiscreteValuationRing.Complete
import Mathlib.NumberTheory.Padics.PadicIntegers
import Mathlib.RingTheory.DedekindDomain.AdicValuation
import LocalClassFieldTheory.ForMathlib.NumberTheory.Padics.PadicIntegers
import LocalClassFieldTheory.ForMathlib.RingTheory.DedekindDomain.Ideal
import LocalClassFieldTheory.FromMathlib.SpecificLimits

#align_import padic_compare

/-!

## Main definitions
* `int.p_height_one_ideal` the ideal `p‚Ñ§` as term of the height_one_spectrum of `‚Ñ§`.

### The field `Q_p`
* `Q_p` is the adic completion of ‚Ñö defined as the uniform completion of the valued field
  `‚Ñö` endowed with its `p`-adic valued structure.
* `padic_pkg'` is the abstract completion of `‚Ñö` whose underlying space is `Q_p`.
* `padic_pkg` is the abstract completion of `‚Ñö` (endowed with the uniformity coming from the
  `p`-adic valued structure) whose underlying space is "usual" `‚Ñö_[p]` defined in terms of the
  `p`-adic metric. In particular, terms of `padic_pkg'.space` are limits of abstract Cauchy filters
    as in `topology.uniform_space.completion` while terms of `padic_pkg.space = ‚Ñö_[p]` are limits
    of Cauchy sequences.
* `padic_valued` The valued structure on `‚Ñö` induced from the `p`-adic valuation.
* `compare` is the uniform equivalence `Q_p p ‚âÉ·µ§ ‚Ñö_[p]` among the underlying spaces of the two
  abstract completions `padic_pkg'` and `padic_pkg`.
* `padic_equiv : (Q_p p) ‚âÉ+* ‚Ñö_[p] :=` The uniform equivalence `compare` as a ring equivalence.

### The integers
* `Z_p` is the unit ball inside `Q_p`.
* `padic'_int.height_one_ideal` The maximal ideal of `Z_p p` as term of the height-one spectrum.
* `padic_int.valuation_subring` Is `‚Ñ§_[p]` seen as valuation_subring if `‚Ñö_[p]`.
* `comap_Zp` Is the valuation subring of `‚Ñö_[p]` that is the image via the isomorphism
  `padic_equiv` of `Z_p`.
* `padic_int_ring_equiv` Is the ring equivalence between `Z_p p` and `‚Ñ§_[p]`.
* `residue_field` Is the ring equivalence between the residue field of `Z_p p` and `‚Ñ§/p‚Ñ§`.


## Main results
* `padic_valued_valuation_p` and `padic'.valuation_p` show that the valuation of `p : ‚Ñö` is the
  same, namely `(-1 : ‚Ñ§‚Çò‚ÇÄ), both when coerced to `‚Ñö_[p]` and to `Q_p p`.
* `valuation_subrings_eq` The equality (as valuation subrings of `‚Ñö_[p]`) between
  `padic_int.valuation_subring` and `comap_Zp`.
* `padic'_int.height_one_ideal_is_principal` is the proof that the maximal ideal of `Z_p` is
  the ideal generated by `p`.


## Implementation details
* In order to put a valued instance on `‚Ñö` coming from the `p`-adic valuation on `‚Ñ§` we have to
  locally remove several instances on it, notably the metric one, the normed one, the densely
  normed field one, the division ring one, the normed additive commutative group one. With these in
  force, there would be clashes between different uniform structures.
* To create the abstract completion `padic_pkg` we regard `‚Ñö_[p]` we need a coercion from `‚Ñö` to
  its completion `‚Ñö_[p]` that is not definitionally equal to the coercion from `‚Ñö` to any field of
  characteristic zero. In particular, we need to manually upgrade this coercion to a ring map in the
  `definition coe_ring_hom : ‚Ñö ‚Üí+* ‚Ñö_[p]`.-/


noncomputable section

open IsDedekindDomain IsDedekindDomain.HeightOneSpectrum

/-- The ideal `p‚Ñ§` as term of the height_one_spectrum of `‚Ñ§`.-/
def Int.pHeightOneIdeal (p : outParam ‚Ñï) [hp : Fact p.Prime] : HeightOneSpectrum ‚Ñ§
    where
  asIdeal := Ideal.span {(p : ‚Ñ§)}
  IsPrime := by
    rw [Ideal.span_singleton_prime]
    exacts [nat.prime_iff_prime_int.mp hp.1, nat.cast_ne_zero.mpr hp.1.NeZero]
  ne_bot := by
    simp only [Ne.def, Ideal.span_singleton_eq_bot, Nat.cast_eq_zero]
    exact hp.1.NeZero

variable (p : outParam ‚Ñï) [Fact p.Prime]

namespace Padic'

open Valuation Int

open scoped DiscreteValuation

attribute [-instance] Rat.metricSpace Rat.normedField Rat.denselyNormedField Rat.divisionRing
  Rat.normedAddCommGroup

instance : SeparatedSpace ‚Ñö_[p] :=
  MetricSpace.to_separated

/-- The valued structure on `‚Ñö` induced by the `p`-adic valuation. -/
def padicValued : Valued ‚Ñö ‚Ñ§‚Çò‚ÇÄ :=
  (pHeightOneIdeal p).adicValued

attribute [local instance] padic_valued

/-- The adic completion of ‚Ñö defined as the uniform completion of the valued field
`‚Ñö` endowed with its `p`-adic valued structure.-/
@[reducible]
def QP : Type _ :=
  adicCompletion ‚Ñö (pHeightOneIdeal p)

instance : IsDiscrete (@Valued.v (QP p) _ ‚Ñ§‚Çò‚ÇÄ _ _) :=
  Completion.isDiscrete _ _ _

instance : NormedField (QP p) :=
  RankOneValuation.ValuedField.toNormedField (QP p) ‚Ñ§‚Çò‚ÇÄ

/-- The abstract completion of `‚Ñö` whose underlying space is `Q_p`. -/
def padicPkg' : AbstractCompletion ‚Ñö where
  Space := QP p
  coe := coe
  /- This `coe` is not the coercion from `‚Ñö` to every field of characteristic zero, but rather the
  coercion from a space to its uniform completion-/
  uniformStruct := inferInstance
  complete := inferInstance
  separation := inferInstance
  UniformInducing := (UniformSpace.Completion.uniformEmbedding_coe ‚Ñö).1
  dense := UniformSpace.Completion.denseRange_coe

end Padic'

namespace PadicComparison

open NNReal Polynomial Int NormalizationMonoid Multiplicative Padic Valuation

open scoped Classical NNReal DiscreteValuation

attribute [-instance] Rat.metricSpace Rat.normedField Rat.denselyNormedField Rat.divisionRing
  Rat.normedAddCommGroup

/-- This is the valued structure on `‚Ñö` induced from the `p`-adic valuation. -/
def padicValued : Valued ‚Ñö ‚Ñ§‚Çò‚ÇÄ :=
  (pHeightOneIdeal p).adicValued

instance : SeparatedSpace ‚Ñö_[p] :=
  MetricSpace.to_separated

attribute [local instance] padic_valued

section Valuation

theorem padicNorm_of_int_eq_val_norm (x : ‚Ñ§) :
    (padicNorm p x : ‚Ñù) = withZeroMultIntToNnreal (NeZero.ne p) (Valued.v (x : ‚Ñö)) :=
  by
  by_cases hx : x = 0
  ¬∑ simp only [hx, padicNorm.zero, algebraMap.coe_zero, _root_.map_zero]
  ¬∑ have hx0 : ¬¨(x : ‚Ñö) = 0 := cast_ne_zero.mpr hx
    have hv0 : Valued.v (x : ‚Ñö) ‚â† (0 : ‚Ñ§‚Çò‚ÇÄ) := by rw [Ne.def, zero_iff]; exact hx0
    have heq :
      Multiplicative.ofAdd
          (-(Associates.mk (p_height_one_ideal p).asIdeal).count
                (Associates.mk (Ideal.span {x} : Ideal ‚Ñ§)).factors :
            ‚Ñ§) =
        WithZero.unzero hv0 :=
      by
      erw [‚Üê WithZero.coe_inj, ‚Üê int_valuation_def_if_neg _ hx, WithZero.coe_unzero,
        valuation_of_algebra_map]
      rfl
    have hx' : (Ideal.span {x} : Ideal ‚Ñ§) ‚â† 0 := by
      rwa [Ideal.zero_eq_bot, Ne.def, Ideal.span_singleton_eq_bot]
    have hp : Prime (p : ‚Ñ§) := nat.prime_iff_prime_int.mp _inst_1.1
    have hp' : (Ideal.span {(p : ‚Ñ§)} : Ideal ‚Ñ§).IsPrime := by
      rwa [Ideal.span_singleton_prime (NeZero.ne (p : ‚Ñ§))]
    have hpne : (Ideal.span {(p : ‚Ñ§)} : Ideal ‚Ñ§) ‚â† ‚ä• := by rw [Ne.def, Ideal.span_singleton_eq_bot];
      exact NeZero.ne (p : ‚Ñ§)
    simp only [padicNorm.eq_zpow_of_nonzero hx0, withZeroMultIntToNnreal,
      withZeroMultIntToNnrealDef, zero_iff, Rat.cast_zpow, Rat.cast_coe_nat,
      MonoidWithZeroHom.coe_mk, dif_neg hx0, coe_zpow, NNReal.coe_nat_cast]
    apply congr_arg
    rw [‚Üê HEq, padicValRat.of_int_multiplicity (Nat.Prime.ne_one _inst_1.1) hx, toAdd_ofAdd,
      neg_inj, Nat.cast_inj, ‚Üê PartENat.natCast_inj, PartENat.natCast_get,
      UniqueFactorizationMonoid.multiplicity_eq_count_normalizedFactors hp.irreducible hx,
      Int.normalize_coe_nat, PartENat.natCast_inj,
      count_normalized_factors_eq_count_normalized_factors_span hx (NeZero.ne p) rfl hp,
      NormalizationMonoid.count_normalizedFactors_eq_associates_count _ _ _ hx' hp' hpne]
    rfl

theorem padicNorm_eq_val_norm (z : ‚Ñö) :
    (padicNorm p z : ‚Ñù) = withZeroMultIntToNnreal (NeZero.ne p) (Valued.v z) :=
  by
  by_cases hz : z = 0
  ¬∑ simp only [hz, padicNorm.zero, algebraMap.coe_zero, _root_.map_zero]
  ¬∑ obtain ‚ü®x, y, hxy‚ü© := IsLocalization.mk'_surjective (nonZeroDivisors ‚Ñ§) z
    have hz : IsLocalization.mk' ‚Ñö x y = x / y := by
      simp only [IsFractionRing.mk'_eq_div, eq_intCast, _root_.coe_coe]
    erw [‚Üê hxy, valuation_of_mk', hz, padicNorm.div, _root_.coe_coe, Rat.cast_div, map_div‚ÇÄ,
      Nonneg.coe_div]
    apply congr_arg‚ÇÇ <;> ¬∑ convert padic_norm_of_int_eq_val_norm p _; erw [valuation_of_algebra_map]

end Valuation

section AbstractCompletion

theorem uniformInducing_coe : UniformInducing (coe : ‚Ñö ‚Üí ‚Ñö_[p]) :=
  by
  have hp_one : (1 : ‚Ñù‚â•0) < p := nat.one_lt_cast.mpr (Nat.Prime.one_lt (Fact.out _))
  apply UniformInducing.mk'
  simp_rw [@Metric.mem_uniformity_dist ‚Ñö_[p] _ _]
  refine' fun S => ‚ü®fun hS => _, _‚ü©
  ¬∑ obtain ‚ü®m, ‚ü®-, hM_sub‚ü©‚ü© := (Valued.hasBasis_uniformity ‚Ñö ‚Ñ§‚Çò‚ÇÄ).mem_iff.mp hS
    set M := (withZeroMultIntToNnreal (NeZero.ne p) m.1).1 with hM
    refine' ‚ü®{p : ‚Ñö_[p] √ó ‚Ñö_[p] | dist p.1 p.2 < M}, ‚ü®‚ü®M, ‚ü®_, fun a b h => h‚ü©‚ü©, fun x y h => _‚ü©‚ü©
    ¬∑ exact withZeroMultIntToNnreal_pos _ (is_unit_iff_ne_zero.mp (Units.isUnit m))
    ¬∑ apply hM_sub
      simp only [Set.mem_setOf_eq, dist] at h ‚ä¢
      rwa [‚Üê Padic.coe_sub, padicNormE.eq_padic_norm', padic_norm_eq_val_norm, hM, Units.val_eq_coe,
        val_eq_coe, NNReal.coe_lt_coe, (withZeroMultIntToNnreal_strictMono hp_one).lt_iff_lt, ‚Üê
        neg_sub, Valuation.map_neg] at h
  ¬∑ rw [(Valued.hasBasis_uniformity ‚Ñö ‚Ñ§‚Çò‚ÇÄ).mem_iff]
    rintro ‚ü®T, ‚ü®Œµ, ‚ü®hŒµ, H‚ü©‚ü©, h‚ü©
    obtain ‚ü®M, hM‚ü© := Real.exists_strictMono_lt (withZeroMultIntToNnreal_strictMono hp_one) hŒµ
    refine' ‚ü®M, by triv, fun q hq => _‚ü©
    simp only [Set.mem_setOf_eq, dist] at H hq
    have : (‚Üëq.fst, ‚Üëq.snd) ‚àà T := by
      apply H
      rw [‚Üê Padic.coe_sub, padicNormE.eq_padic_norm', padic_norm_eq_val_norm, ‚Üê neg_sub,
        Valuation.map_neg]
      exact
        (nnreal.coe_lt_coe.mpr ((withZeroMultIntToNnreal_strictMono hp_one).lt_iff_lt.mpr hq)).trans
          hM
    specialize h q.1 q.2 this
    rwa [Prod.mk.eta] at h

theorem dense_coe : DenseRange (coe : ‚Ñö ‚Üí ‚Ñö_[p]) :=
  Metric.denseRange_iff.mpr (Padic.rat_dense p)

/-- The abstract completion of `‚Ñö` (endowed with the uniformity coming from the `p`-adic valued
  structure) whose underlying space is `‚Ñö_[p]`-/
def padicPkg : AbstractCompletion ‚Ñö where
  Space := ‚Ñö_[p]
  coe := coe
  uniformStruct := inferInstance
  complete := inferInstance
  separation := inferInstance
  UniformInducing := uniformInducing_coe p
  dense := dense_coe p

/-- The coercion from the uniform space `‚Ñö` to its uniform completion `‚Ñö_[p]` as a ring
  homomorphims. Beware that this is not the coercion from `‚Ñö` to `‚Ñö_[p]` induced from the structure
  of characteristic-zero field on `‚Ñö_[p]`. -/
def coeRingHom : ‚Ñö ‚Üí+* ‚Ñö_[p] where
  toFun := (padicPkg p).2
  map_one' := Rat.cast_one
  map_mul' := Rat.cast_mul
  map_zero' := Rat.cast_zero
  map_add' := Rat.cast_add

end AbstractCompletion

open Padic'

section Comparison

/-- The main result is the uniform equivalence from `Q_p p` and `‚Ñö_[p]`-/
def compare : QP p ‚âÉ·µ§ ‚Ñö_[p] :=
  AbstractCompletion.compareEquiv (padicPkg' p) (padicPkg p)

theorem uniformContinuous_coe : UniformContinuous (coe : ‚Ñö ‚Üí ‚Ñö_[p]) :=
  (uniformInducing_iff'.1 (uniformInducing_coe p)).1

/-- The upgrade of the comparison as a ring homomorphism -/
def extensionAsRingHom : QP p ‚Üí+* ‚Ñö_[p] :=
  UniformSpace.Completion.extensionHom (coeRingHom p) (uniformContinuous_coe p).Continuous

@[simp]
theorem extensionAsRingHom_toFun :
    (extensionAsRingHom p).toFun = UniformSpace.Completion.extension (coe : ‚Ñö ‚Üí ‚Ñö_[p]) :=
  rfl

theorem extension_eq_compare : (extensionAsRingHom p).toFun = (compare p).toFun :=
  by
  simp only [extension_as_ring_hom_to_fun, Equiv.toFun_as_coe, UniformEquiv.coe_toEquiv]
  apply
    UniformSpace.Completion.extension_unique (uniform_continuous_coe p)
      ((padic_pkg' p).uniformContinuous_compareEquiv (padic_pkg p))
  intro a
  have : (padic_pkg p).coe a = (‚Üëa : ‚Ñö_[p]) := rfl
  rw [‚Üê this, ‚Üê AbstractCompletion.compare_coe]
  rfl

/-- The uniform equivalence `compare` as a ring equivalence -/
def padicEquiv : QP p ‚âÉ+* ‚Ñö_[p] :=
  {
    compare
      p with
    map_mul' := by rw [‚Üê extension_eq_compare p]; use(extension_as_ring_hom p).map_mul'
    map_add' := by rw [‚Üê extension_eq_compare p]; exact (extension_as_ring_hom p).map_add' }

instance : CharZero (QP p) :=
  (padicEquiv p).toRingHom.CharZero

instance : Algebra ‚Ñö_[p] (QP p) :=
  RingHom.toAlgebra (PadicComparison.padicEquiv p).symm

instance : IsScalarTower ‚Ñö ‚Ñö_[p] (QP p)
    where smul_assoc r x y :=
    by
    simp only [Algebra.smul_def, eq_ratCast, _root_.map_mul, map_ratCast, mul_assoc]
    rfl

theorem Padic'.coe_eq (x : ‚Ñö) : (x : QP p) = ((padicPkg' p).coe x : (padicPkg' p).Space) :=
  by
  have hp : (x : Q_p p) = (padic_pkg p).compare (padic_pkg' p) (x : ‚Ñö_[p]) :=
    by
    have h : (padic_pkg p).compare (padic_pkg' p) (x : ‚Ñö_[p]) = algebraMap ‚Ñö_[p] (Q_p p) x := rfl
    rw [h, map_ratCast]
  rw [‚Üê AbstractCompletion.compare_coe (padic_pkg p) (padic_pkg' p), hp]
  rfl

theorem padicValued_valuation_p : @Valued.v ‚Ñö _ ‚Ñ§‚Çò‚ÇÄ _ (padicValued p) (p : ‚Ñö) = ofAdd (-1 : ‚Ñ§) :=
  by
  have hp : (p : ‚Ñö) = algebraMap ‚Ñ§ ‚Ñö (p : ‚Ñ§) := rfl
  rw [adic_valued_apply, hp, valuation_of_algebra_map, int_valuation_apply,
    int_valuation_def_if_neg (p_height_one_ideal p)
      (nat.cast_ne_zero.mpr (Nat.Prime.ne_zero _inst_1.1))]
  congr
  apply Associates.count_self
  rw [Associates.irreducible_mk]
  apply Prime.irreducible
  exact
    Ideal.prime_of_isPrime
      (ideal.span_singleton_eq_bot.mp.mt (nat.cast_ne_zero.mpr (Nat.Prime.ne_zero _inst_1.1)))
      (Ideal.IsMaximal.isPrime' (p_height_one_ideal p).asIdeal)

theorem Padic'.valuation_p : Valued.v (p : QP p) = ofAdd (-1 : ‚Ñ§) :=
  by
  letI : Valued ‚Ñö ‚Ñ§‚Çò‚ÇÄ := padic_valued p
  have hp : (p : Q_p p) = ((coe : ‚Ñö ‚Üí Q_p p) p : Q_p p) :=
    by
    have : ‚àÄ x : ‚Ñö, (coe : ‚Ñö ‚Üí Q_p p) x = (x : Q_p p) := by intro x; rw [padic'.coe_eq]; rfl
    rw [this]; simp only [Rat.cast_coe_nat]
  rw [hp, Valued.valuedCompletion_apply (p : ‚Ñö), padic_valued_valuation_p p]

end Comparison

section ZP

/-- The unit ball in `Q_p` -/
@[reducible]
def zP :=
  (@Valued.v (QP p) _ ‚Ñ§‚Çò‚ÇÄ _ _).ValuationSubring

theorem exists_mem_le_one_of_lt_one {x : QP p} (hx : Valued.v x ‚â§ (1 : ‚Ñ§‚Çò‚ÇÄ)) :
    ‚àÉ y : zP p, (y : QP p) = x ‚àß Valued.v (y : QP p) = Valued.v x :=
  by
  have hv := valued.v.is_equiv_valuation_valuation_subring
  have := ValuationSubring.mem_of_valuation_le_one (Z_p p) x _
  use‚ü®x, this‚ü©
  simp only [SetLike.coe_mk, eq_self_iff_true, and_self_iff]
  exact ((Valuation.isEquiv_iff_val_le_one _ _).mp hv).mp hx

theorem exists_mem_lt_one_of_lt_one {x : QP p} (hx : Valued.v x < (1 : ‚Ñ§‚Çò‚ÇÄ)) :
    ‚àÉ y : zP p, (y : QP p) = x ‚àß Valued.v (y : QP p) = Valued.v x :=
  by
  have hv := valued.v.is_equiv_valuation_valuation_subring
  have := ValuationSubring.mem_of_valuation_le_one (Z_p p) x (le_of_lt _)
  use‚ü®x, this‚ü©
  simp only [SetLike.coe_mk, eq_self_iff_true, and_self_iff]
  exact ((Valuation.isEquiv_iff_val_lt_one _ _).mp hv).mp hx

instance : CharZero (zP p)
    where cast_injective m n h :=
    by
    simp only [Subtype.ext_iff, Subring.coe_natCast, Nat.cast_inj] at h
    exact h

/-- The maximal ideal of `Z_p p` as an element of the height-one spectrum -/
def Padic'Int.heightOneIdeal : HeightOneSpectrum (zP p)
    where
  asIdeal := LocalRing.maximalIdeal (zP p)
  IsPrime := Ideal.IsMaximal.isPrime (LocalRing.maximalIdeal.isMaximal _)
  ne_bot := by
    simpa [Ne.def, ‚Üê LocalRing.isField_iff_maximalIdeal_eq] using DiscreteValuation.not_isField _

theorem Padic'Int.heightOneIdeal_is_principal :
    (Padic'Int.heightOneIdeal p).asIdeal = Ideal.span {(p : Z_p p)} :=
  DiscreteValuation.isUniformizer_is_generator _ (Padic'.valuation_p p)

instance : Valued (QP p) ‚Ñ§‚Çò‚ÇÄ :=
  HeightOneSpectrum.valuedAdicCompletion ‚Ñö (pHeightOneIdeal p)

/-- The ring `‚Ñ§_[p]` as a valuation subring of `‚Ñö_[p]`. -/
def PadicInt.valuationSubring : ValuationSubring ‚Ñö_[p]
    where
  toSubring := PadicInt.subring p
  mem_or_inv_mem' :=
    by
    have not_field : ¬¨IsField ‚Ñ§_[p] := DiscreteValuationRing.not_isField _
    -- Marking `not_field` as a separate assumption makes the computation faster
    have := ((DiscreteValuationRing.TFAE ‚Ñ§_[p] not_field).out 0 1).mp PadicInt.discreteValuationRing
    intro x
    rcases(ValuationRing.iff_isInteger_or_isInteger ‚Ñ§_[p] ‚Ñö_[p]).mp this x with (hx | hx)
    ¬∑ apply Or.intro_left
      obtain ‚ü®y, hy‚ü© := hx
      rw [‚Üê hy]
      simp only [PadicInt.algebraMap_apply, Subring.mem_carrier, PadicInt.mem_subring_iff,
        PadicInt.padic_norm_e_of_padicInt]
      apply PadicInt.norm_le_one
    ¬∑ apply Or.intro_right
      obtain ‚ü®y, hy‚ü© := hx
      rw [‚Üê hy]
      simp only [PadicInt.algebraMap_apply, Subring.mem_carrier, PadicInt.mem_subring_iff,
        PadicInt.padic_norm_e_of_padicInt]
      apply PadicInt.norm_le_one

open Filter

open scoped Filter Topology

/-- The valuation subring of `‚Ñö_[p]` that is the image via the isomorphism `padic_equiv` of `Z_p`-/
@[reducible]
def comapZp : ValuationSubring ‚Ñö_[p] :=
  ValuationSubring.comap (zP p) (padicEquiv p).symm.toRingHom

/-- The two lemmas `padic_int.nonunit_mem_iff_top_nilpotent` and
`unit_ball.nonunit_mem_iff_top_nilpotent` have basically the same proof, except that in the first we
 use that `x : ‚Ñö_[p]` satisfies ‚Äñ x ‚Äñ < 1 iff `p ‚à£ x` and in the other that `x : (Q_p p)` satisfies
 `‚Äñ x ‚Äñ < 1` iff it belongs to the maximal ideal. -/
theorem PadicInt.nonunit_mem_iff_top_nilpotent (x : ‚Ñö_[p]) :
    x ‚àà (PadicInt.valuationSubring p).nonunits ‚Üî Filter.Tendsto (fun n : ‚Ñï => x ^ n) atTop (ùìù 0) :=
  by
  have aux : ‚àÄ n : ‚Ñï, ‚Äñx ^ n‚Äñ = ‚Äñx‚Äñ ^ n := fun n => norm_pow _ n
  rw [tendsto_zero_iff_norm_tendsto_zero, Filter.tendsto_congr aux]
  refine' ‚ü®fun H => _, fun H => _‚ü©
  ¬∑ obtain ‚ü®h1, h2‚ü© := valuation_subring.mem_nonunits_iff_exists_mem_maximal_ideal.mp H
    exact
      _root_.tendsto_pow_at_top_nhds_0_of_lt_1 (norm_nonneg _)
        (padic_int.mem_nonunits.mp <| (LocalRing.mem_maximalIdeal _).mp h2)
  ¬∑ have : ‚Äñx‚Äñ < 1 :=
      by
      suffices (‚ü®‚Äñx‚Äñ, norm_nonneg _‚ü© : ‚Ñù‚â•0) < 1 by
        rwa [‚Üê NNReal.coe_lt_coe, NNReal.coe_one, ‚Üê Subtype.val_eq_coe] at this
      apply NNReal.lt_one_of_tendsto_pow_0
      rwa [‚Üê NNReal.tendsto_coe, NNReal.coe_zero]
    apply valuation_subring.mem_nonunits_iff_exists_mem_maximal_ideal.mpr
    exact
      ‚ü®(PadicInt.mem_subring_iff p).mpr (le_of_lt this),
        (LocalRing.mem_maximalIdeal _).mpr (padic_int.mem_nonunits.mpr this)‚ü©

@[nolint unused_arguments]
theorem mem_unit_ball_of_tendsto_zero {x : QP p} (H : Tendsto (fun n : ‚Ñï => ‚Äñx‚Äñ ^ n) atTop (ùìù 0))
    (h_go : ‚Äñx‚Äñ < 1) : x ‚àà (zP p).nonunits :=
  by
  apply valuation_subring.mem_nonunits_iff_exists_mem_maximal_ideal.mpr
  have : ‚Äñx‚Äñ < 1 :=
    by
    suffices (‚ü®‚Äñx‚Äñ, norm_nonneg _‚ü© : ‚Ñù‚â•0) < 1 by
      rwa [‚Üê NNReal.coe_lt_coe, NNReal.coe_one, ‚Üê Subtype.val_eq_coe] at this
    apply NNReal.lt_one_of_tendsto_pow_0
    rw [‚Üê NNReal.tendsto_coe, NNReal.coe_zero]
    exact H
  replace this : Valued.v x < (1 : ‚Ñ§‚Çò‚ÇÄ)
  ¬∑ apply (RankOneValuation.norm_lt_one_iff_val_lt_one x).mp this
  obtain ‚ü®y, hy‚ÇÅ, hy‚ÇÇ‚ü© := exists_mem_lt_one_of_lt_one p this
  rw [‚Üê hy‚ÇÇ] at this
  rw [‚Üê hy‚ÇÅ]
  simp only [mem_valuation_subring_iff, SetLike.eta, exists_prop]
  refine' ‚ü®le_of_lt this, _‚ü©
  rw [‚Üê completion.adic_of_compl_eq_compl_of_adic ‚Ñ§ (p_height_one_ideal p) ‚Ñö ‚Üëy] at this
  let M := completion.max_ideal_of_completion ‚Ñ§ (p_height_one_ideal p) ‚Ñö
  have v_lt_one :=
    @IsDedekindDomain.HeightOneSpectrum.valuation_lt_one_iff_dvd (Z_p p) _ _ _ (Q_p p) _ _ _
      (completion.max_ideal_of_completion ‚Ñ§ (p_height_one_ideal p) ‚Ñö) y
  have eq_y : (algebraMap (‚Ü•(Z_p p)) (Q_p p)) y = (‚Üëy : Q_p p) := rfl
  rw [eq_y] at v_lt_one
  simp only [v_lt_one, Ideal.dvd_span_singleton, mem_nonunits_iff,
    ValuationSubring.algebraMap_apply, SetLike.coe_mk, forall_true_left] at this
  exact this

theorem UnitBall.nonunit_mem_iff_top_nilpotent (x : QP p) :
    x ‚àà (zP p).nonunits ‚Üî Filter.Tendsto (fun n : ‚Ñï => x ^ n) atTop (ùìù 0) :=
  by
  have h_max_ideal : (padic'_int.height_one_ideal p).asIdeal = LocalRing.maximalIdeal ‚Ü•(Z_p p) :=
    rfl
  have aux : ‚àÄ n : ‚Ñï, ‚Äñx ^ n‚Äñ = ‚Äñx‚Äñ ^ n := fun n => norm_pow _ n
  rw [tendsto_zero_iff_norm_tendsto_zero, Filter.tendsto_congr aux]
  refine' ‚ü®fun H => _, fun H => _‚ü©
  ¬∑ simp_rw [norm_pow]
    obtain ‚ü®h, x_mem‚ü© := valuation_subring.mem_nonunits_iff_exists_mem_maximal_ideal.mp H
    have :=
      (@valuation_lt_one_iff_dvd (Z_p p) _ _ _ (Q_p p) _ _ _ (padic'_int.height_one_ideal p)
          ‚ü®x, h‚ü©).mpr
    simp only [h_max_ideal, Ideal.dvd_span_singleton, mem_nonunits_iff,
      ValuationSubring.algebraMap_apply, SetLike.coe_mk, x_mem, forall_true_left] at this
    replace this : Valued.v x < (1 : ‚Ñ§‚Çò‚ÇÄ)
    ¬∑ convert this using 1
      exact (completion.adic_of_compl_eq_compl_of_adic ‚Ñ§ (Int.pHeightOneIdeal p) ‚Ñö x).symm
    exact
      _root_.tendsto_pow_at_top_nhds_0_of_lt_1 (norm_nonneg _)
        ((RankOneValuation.norm_lt_one_iff_val_lt_one _).mpr this)
  ¬∑ have : ‚Äñx‚Äñ < 1 :=
      by
      suffices (‚ü®‚Äñx‚Äñ, norm_nonneg _‚ü© : ‚Ñù‚â•0) < 1 by
        rwa [‚Üê NNReal.coe_lt_coe, NNReal.coe_one, ‚Üê Subtype.val_eq_coe] at this
      apply NNReal.lt_one_of_tendsto_pow_0
      rwa [‚Üê NNReal.tendsto_coe, NNReal.coe_zero]
    apply mem_unit_ball_of_tendsto_zero p H this

theorem mem_nonunits_iff (x : QP p) :
    x ‚àà (zP p).nonunits ‚Üî (padicEquiv p) x ‚àà (comapZp p).nonunits :=
  by
  let œÜ : Z_p p ‚âÉ+* comap_Zp p :=
    by
    have := (Z_p p).toSubring.comap_equiv_eq_map_symm (padic_equiv p).symm
    replace this := RingEquiv.subringCongr this.symm
    use(@RingEquiv.subringMap _ _ _ _ (Z_p p).toSubring (padic_equiv p)).trans this
  refine' ‚ü®fun hx => _, fun hx => _‚ü©
  all_goals
    rw [ValuationSubring.mem_nonunits_iff_exists_mem_maximalIdeal] at hx
    rw [ValuationSubring.mem_nonunits_iff_exists_mem_maximalIdeal]
  ¬∑ refine' ‚ü®_, map_nonunit (‚ÜëœÜ : Z_p p ‚Üí+* comap_Zp p) _ hx.some_spec‚ü©
  ¬∑ rcases hx with ‚ü®h1, h2‚ü©
    have h3 := valuation_subring.mem_comap.mp h1
    have :
      (padic_equiv p).symm.toRingHom ((padic_equiv p) x) =
        (padic_equiv p).symm.toRingHom ((padic_equiv p).toRingHom x) :=
      rfl
    simp_rw [this, ‚Üê RingHom.comp_apply, RingEquiv.symm_toRingHom_comp_toRingHom,
      RingHom.id_apply] at h3
    have h4 : œÜ.symm (‚ü®(padic_equiv p) x, h1‚ü© : { z // z ‚àà comap_Zp p }) = ‚ü®x, h3‚ü© :=
      by
      set b : ‚Ñö_[p] := œÜ ‚ü®x, h3‚ü© with hb
      have : b = (padic_equiv p) x := rfl
      simp_rw [‚Üê this, hb, SetLike.eta, RingEquiv.symm_apply_apply]
    replace h2 := map_nonunit (‚ÜëœÜ.symm : comap_Zp p ‚Üí+* Z_p p) _ h2
    erw [h4] at h2
    refine' ‚ü®_, h2‚ü©

theorem valuation_subrings_eq : PadicInt.valuationSubring p = comapZp p :=
  by
  rw [‚Üê ValuationSubring.nonunits_inj]
  ext x
  refine' ‚ü®fun hx => _, fun hx => _‚ü©
  ¬∑ rw [‚Üê (padic_equiv p).apply_symm_apply x]
    rw [‚Üê mem_nonunits_iff, unit_ball.nonunit_mem_iff_top_nilpotent, ‚Üê
      _root_.map_zero (padic_equiv p).symm]
    simp_rw [‚Üê _root_.map_pow (padic_equiv p).symm]
    apply (@Continuous.continuousAt _ _ _ _ _ 0 (compare p).3.Continuous).Tendsto.comp
    rwa [‚Üê padic_int.nonunit_mem_iff_top_nilpotent]
  ¬∑ rw [‚Üê (padic_equiv p).apply_symm_apply x, ‚Üê mem_nonunits_iff,
      unit_ball.nonunit_mem_iff_top_nilpotent] at hx
    replace hx :=
      @tendsto.comp ‚Ñï (Q_p p) ‚Ñö_[p] (fun n => (padic_equiv p).symm x ^ n) (padic_equiv p) at_top
        (ùìù 0) (ùìù 0) _ hx
    -- We postpone the verification of the first assumption in `tendsto.comp`
    ¬∑ simp_rw [‚Üê _root_.map_pow (padic_equiv p).symm x, Function.comp,
        RingEquiv.apply_symm_apply] at hx
      rwa [padic_int.nonunit_mem_iff_top_nilpotent]
    ¬∑ rw [‚Üê _root_.map_zero (padic_equiv p)]
      apply Continuous.tendsto (compare p).symm.3.Continuous 0

theorem padic_int_ring_equiv_range : (zP p).map (padicEquiv p).toRingHom = PadicInt.subring p :=
  by
  have : (comap_Zp p).toSubring = (padic_int.valuation_subring p).toSubring
  rw [‚Üê valuation_subrings_eq]
  convert this
  ext x
  simp only [Subring.mem_carrier, Subring.mem_map, mem_valuation_subring_iff, exists_prop,
    ValuationSubring.mem_comap]
  constructor
  ¬∑ rintro ‚ü®y, ‚ü®hy, H‚ü©‚ü©
    rw [‚Üê H]
    simp only [ValuationSubring.mem_toSubring, ValuationSubring.mem_comap,
      RingEquiv.symm_toRingHom_apply_toRingHom_apply, mem_valuation_subring_iff] at hy ‚ä¢
    exact hy
  ¬∑ intro hx
    simp at hx
    use(padic_equiv p).symm.toRingHom x
    constructor
    ¬∑ simp only [ValuationSubring.mem_toSubring, mem_valuation_subring_iff]
      exact hx
    simp only [RingEquiv.toRingHom_apply_symm_toRingHom_apply]

/-- The ring equivalence between `Z_p p` and `‚Ñ§_[p]`. -/
noncomputable def padicIntRingEquiv : zP p ‚âÉ+* ‚Ñ§_[p] :=
  (RingEquiv.subringMap _).trans (RingEquiv.subringCongr (padic_int_ring_equiv_range p))

/-- The ring equivalence between the residue field of `Z_p p` and `‚Ñ§/p‚Ñ§`. -/
def residueField : LocalRing.ResidueField (zP p) ‚âÉ+* ZMod p :=
  (LocalRing.ResidueField.mapEquiv (padicIntRingEquiv p)).trans (PadicInt.residueField p)

end ZP

end PadicComparison
